// schemaCrm.prisma (CRM)
generator client {
  provider      = "prisma-client-js"
  output        = "./generated/crm" // Define un output específico para el cliente CRM
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_CRM_URL")
}

// schemaCrm.prisma
model Empresa {
  id               Int                @id @default(autoincrement())
  nombre           String
  direccion        String?
  telefono         String?
  pbx              String?
  correo           String?
  sitioWeb         String?
  nit              String? // Número de identificación tributaria
  logo1            String? // URL o path del logo de la empresa
  logo2            String? // URL o path del logo de la empresa
  logo3            String? // URL o path del logo de la empresa
  // saldo           Int?     // Saldo pendiente o registrado de la empresa
  creadoEn         DateTime           @default(now())
  actualizadoEn    DateTime           @updatedAt
  // Relaciones
  empleados        Usuario[] // Empleados, cobradores, técnicos, etc.
  rutas            Ruta[] // Rutas asignadas para cobranza
  clientesInternet ClienteInternet[] // Clientes de servicio de internet
  facturas         FacturaInternet[] // Facturas generadas para clientes
  TicketSoporte    TicketSoporte[]
  saldoEmpresa     SaldoEmpresa?
  saldoCaja        SaldoCaja?
  ServicioInternet ServicioInternet[]
  Ubicacion        Ubicacion[]
  Proveedor        Proveedor[]
  Servicio         Servicio[]
  Factura          Factura[]

  //
  @@unique([nombre]) // Evita duplicados de empresas
}

model TipoServicio {
  id          Int            @id @default(autoincrement())
  nombre      String         @unique // Nombre del tipo de servicio (Ej: "Internet", "IPTV")
  descripcion String? // Información adicional sobre el tipo de servicio
  estado      EstadoServicio @default(ACTIVO) // Activo o inactivo

  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt

  servicios Servicio[]
}

model Servicio {
  id          Int            @id @default(autoincrement())
  nombre      String // Ejemplo: "Plan Básico Q150", "IPTV Full", "Cámara HD"
  descripcion String?
  precio      Float // Precio del servicio
  estado      EstadoServicio @default(ACTIVO)

  tipoServicioId Int // Relación con TipoServicio
  tipoServicio   TipoServicio @relation(fields: [tipoServicioId], references: [id], onDelete: Restrict)

  empresaId Int
  empresa   Empresa @relation(fields: [empresaId], references: [id], onDelete: Cascade)

  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt

  clientes ClienteServicio[]

  FacturaServicio FacturaServicio[]
}

model Proveedor {
  id        Int     @id @default(autoincrement())
  nombre    String
  correo    String?
  telefono  String?
  direccion String?
  empresaId Int
  empresa   Empresa @relation(fields: [empresaId], references: [id], onDelete: Cascade)
}

model ServicioInternet {
  id            Int               @id @default(autoincrement())
  nombre        String // Ejemplo: "Plan Básico Q150", "Plan Premium Q250"
  velocidad     String? // Ejemplo: "20 Mbps", "50 Mbps"
  precio        Float // Precio del servicio
  estado        EstadoServicio    @default(ACTIVO) // Control de disponibilidad del plan
  creadoEn      DateTime          @default(now())
  actualizadoEn DateTime          @updatedAt
  clientes      ClienteInternet[]
  empresaId     Int
  empresa       Empresa           @relation(fields: [empresaId], references: [id], onDelete: Cascade)
}

model SaldoEmpresa {
  id            Int      @id @default(autoincrement())
  saldo         Float    @default(0)
  egresos       Float    @default(0)
  totalIngresos Float
  empresaId     Int      @unique
  empresa       Empresa  @relation(references: [id], fields: [empresaId], onDelete: Cascade)
  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt
}

model SaldoCaja {
  id            Int   @id @default(autoincrement())
  saldo         Float @default(0)
  egreso        Float @default(0)
  totalIngresos Float
  totalEgresos  Float

  empresaId Int     @unique
  empresa   Empresa @relation(references: [id], fields: [empresaId], onDelete: Cascade)

  creadoEn      DateTime       @default(now())
  actualizadoEn DateTime       @updatedAt
  registrosCaja RegistroCaja[]
}

model RegistroCaja {
  id           Int   @id @default(autoincrement())
  saldoInicial Float
  saldoFinal   Float

  usuarioId Int? // Clave foránea opcional
  usuario   Usuario? @relation(fields: [usuarioId], references: [id], onDelete: Cascade) // Relación opcional

  cajaId Int? // Clave foránea opcional
  caja   SaldoCaja? @relation(fields: [cajaId], references: [id], onDelete: SetNull) // Relación opcional

  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt
}

model ClienteServicio {
  id Int @id @default(autoincrement())

  clienteId Int
  cliente   ClienteInternet @relation(fields: [clienteId], references: [id], onDelete: Cascade)

  servicioId Int
  servicio   Servicio @relation(fields: [servicioId], references: [id], onDelete: Cascade)

  fechaInicio DateTime              @default(now())
  fechaFin    DateTime?
  estado      EstadoClienteServicio @default(ACTIVO)

  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt
}

model Factura {
  id        Int     @id @default(autoincrement())
  empresaId Int
  empresa   Empresa @relation(fields: [empresaId], references: [id], onDelete: Cascade)

  clienteId Int
  cliente   ClienteInternet @relation(fields: [clienteId], references: [id], onDelete: Cascade)

  tipoFactura      TipoFactura // Define si es una factura de Internet u otro servicio
  montoTotal       Float
  saldoPendiente   Float         @default(0)
  fechaEmision     DateTime      @default(now())
  fechaVencimiento DateTime?
  estado           EstadoFactura @default(PENDIENTE)

  servicios FacturaServicio[]
  pagos     PagoFactura[]

  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt
}

model PagoFactura {
  id Int @id @default(autoincrement())

  facturaId Int
  factura   Factura @relation(fields: [facturaId], references: [id], onDelete: Cascade)

  clienteId Int
  cliente   ClienteInternet @relation(fields: [clienteId], references: [id], onDelete: Cascade)

  montoPagado Float
  metodoPago  MetodoPago
  fechaPago   DateTime   @default(now())

  creadoEn DateTime @default(now())
}

// model FacturaInternet {
//   //factura, o cobro, que se hace de forma mensual, a los clientes por sus servicios, tienen una fecha de pago, esa fecha puede expirar, y deberíamos tomar la fecha pagada, tambien, registrar que usuario le cobró, registró el pago
//   id  Int @id() @default(autoincrement())
//   fechaPagoEsperada DateTime? 
//   fechaPagada DateTime? 
//   montoPago Int?
//   EmpresaId Int
//   Empresa Empresa @relation(fields: [EmpresaId], references: [id], onDelete: Cascade)
//   metodoPago MetodoPagoFacturaInternet
//   clienteId Int
//   cliente ClienteInternet @relation(references: [id], fields: [clienteId], onDelete: Cascade)
//   estadoFacturaInternet EstadoFacturaInternet @default(PENDIENTE)
//   creadoEn     DateTime  @default(now())
//   actualizadoEn DateTime @updatedAt
//   PagoFacturaInternet PagoFacturaInternet[]
// }

model FacturaInternet {
  id                    Int                       @id @default(autoincrement())
  fechaPagoEsperada     DateTime?
  fechaPagada           DateTime?
  montoPago             Float? // Monto total de la factura mensual
  saldoPendiente        Float?                    @default(0) // Nuevo campo: lo que queda por pagar
  empresaId             Int
  empresa               Empresa                   @relation(fields: [empresaId], references: [id], onDelete: Cascade)
  metodoPago            MetodoPagoFacturaInternet
  clienteId             Int
  cliente               ClienteInternet           @relation(fields: [clienteId], references: [id], onDelete: Cascade)
  estadoFacturaInternet EstadoFacturaInternet     @default(PENDIENTE)
  pagos                 PagoFacturaInternet[] // Relación 1:N, puede tener múltiples pagos
  creadoEn              DateTime                  @default(now())
  actualizadoEn         DateTime                  @updatedAt
}

model PagoFacturaInternet {
  id                Int                       @id @default(autoincrement())
  facturaInternetId Int
  facturaInternet   FacturaInternet           @relation(fields: [facturaInternetId], references: [id], onDelete: Cascade)
  clienteId         Int
  cliente           ClienteInternet           @relation(fields: [clienteId], references: [id], onDelete: Cascade)
  montoPagado       Float
  metodoPago        MetodoPagoFacturaInternet
  fechaPago         DateTime                  @default(now())
  creadoEn          DateTime                  @default(now())
}

model FacturaServicio {
  id Int @id @default(autoincrement())

  facturaId Int
  factura   Factura @relation(fields: [facturaId], references: [id], onDelete: Cascade)

  servicioId Int
  servicio   Servicio @relation(fields: [servicioId], references: [id], onDelete: Cascade)

  cantidad       Int   @default(1)
  precioUnitario Float
  total          Float

  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt
}

// Estudiar esto
model IP {
  id          Int              @id @default(autoincrement())
  direccionIp String? // La dirección IP es opcional
  clienteId   Int?             @unique // Relación uno a uno, asegura que un cliente solo pueda tener una IP
  cliente     ClienteInternet? @relation(fields: [clienteId], references: [id], onDelete: Cascade) // Relación opcional
}

model Fotos {
  id         Int     @id @default(autoincrement())
  nombreFoto String
  url        String?

  clienteId Int
  cliente   ClienteInternet @relation(fields: [clienteId], references: [id], onDelete: Cascade)

  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt
}

// Estudiar esta relacion uno a uno
model ClienteInternet {
  id            Int     @id() @default(autoincrement())
  nombre        String
  telefono      String?
  direccion     String?
  dpi           String? // Campo DPI opcional
  observaciones String?

  //otros datos referncia
  contactoReferenciaNombre   String?
  contactoReferenciaTelefono String?

  estadoCliente EstadoCliente

  //DATOS DEL SERVICIO
  contrasenaWifi   String
  ssidRouter       String?
  fechaInstalacion DateTime?
  asesorId         Int?
  asesor           Usuario?  @relation(references: [id], fields: [asesorId], onDelete: SetNull)

  servicioId     Int // Relación con ServicioInternet
  servicio       ServicioInternet @relation(fields: [servicioId], references: [id], onDelete: Restrict)
  //
  municipioId    Int?
  municipio      Municipio?       @relation(fields: [municipioId], references: [id], onDelete: SetNull)
  departamentoId Int?
  departamento   Departamento?    @relation(fields: [departamentoId], references: [id], onDelete: SetNull)
  empresaId      Int
  empresa        Empresa          @relation(fields: [empresaId], references: [id], onDelete: Cascade)
  ruta           Ruta[] //rutas a las que puede ser referenciado
  IP             IP?              @relation() // Relación opcional con IP, un solo cliente puede tener una IP
  ubicacion      Ubicacion?

  ticketSoporte TicketSoporte[]
  saldoCliente  saldoCliente?

  creadoEn      DateTime @default(now())
  actualizadoEn DateTime @updatedAt
  //fotos y referencias del cliente
  fotos         Fotos[]

  //OTROS SERVICIOS COMO IPTV, CAMÁRAS, SASS, ETC.
  clienteServicio     ClienteServicio[]
  //facturas que generamos mes a mes internet
  facturaInternet     FacturaInternet[]
  PagoFacturaInternet PagoFacturaInternet[]
  // Facturas y pagos del cliente
  factura             Factura[]
  pagoFactura         PagoFactura[]
}

model saldoCliente {
  id             Int    @id @default(autoincrement())
  saldoPendiente Float?
  saldoFavor     Float?
  totalPagos     Float?

  clienteId     Int             @unique
  cliente       ClienteInternet @relation(fields: [clienteId], references: [id], onDelete: Cascade)
  creadoEn      DateTime        @default(now())
  actualizadoEn DateTime        @updatedAt
}

model Ubicacion {
  id        Int             @id @default(autoincrement())
  creadoEn  DateTime        @default(now())
  latitud   Float?
  longitud  Float?
  clienteId Int             @unique // Necesitas especificar UNIQUE para que sea uno a uno
  cliente   ClienteInternet @relation(references: [id], fields: [clienteId], onDelete: Cascade)
  empresaId Int
  empresa   Empresa         @relation(fields: [empresaId], references: [id], onDelete: Cascade)
}

model Departamento {
  id         Int               @id @default(autoincrement())
  nombre     String            @unique
  municipios Municipio[] // Relación con municipios
  clientes   ClienteInternet[] // Relación con los clientes
}

model Municipio {
  id             Int               @id @default(autoincrement())
  nombre         String            @unique
  departamentoId Int
  departamento   Departamento      @relation(fields: [departamentoId], references: [id], onDelete: Cascade)
  clientes       ClienteInternet[] // Relación con los clientes
}

model Ruta {
  id           Int               @id @default(autoincrement())
  nombreRuta   String
  cobradorId   Int
  cobrador     Usuario           @relation(fields: [cobradorId], references: [id], onDelete: Cascade) // Lo relacionamos con quien va a cobrar
  cobrados     Int // Número de clientes cobrados en la ruta
  montoCobrado Int // Monto total cobrado en la ruta
  Clientes     ClienteInternet[] // Relación con clientes asignados a la ruta
  estadoRuta   EstadoRuta
  EmpresaId    Int
  Empresa      Empresa           @relation(fields: [EmpresaId], references: [id], onDelete: Cascade)
}

model TicketSoporte {
  id        Int             @id @default(autoincrement())
  clienteId Int // Cliente que solicita el soporte | cliente asignado
  cliente   ClienteInternet @relation(fields: [clienteId], references: [id], onDelete: Cascade)

  empresaId Int
  empresa   Empresa @relation(fields: [empresaId], references: [id], onDelete: Cascade)

  tecnicoId Int? // Técnico asignado
  tecnico   Usuario? @relation("TicketTecnico", fields: [tecnicoId], references: [id], onDelete: SetNull)

  creadoPorId Int? // Usuario que creó el ticket
  creadoPor   Usuario? @relation("TicketCreador", fields: [creadoPorId], references: [id], onDelete: SetNull)

  estado        EstadoTicketSoporte    @default(ABIERTA)
  prioridad     PrioridadTicketSoporte @default(MEDIA)
  descripcion   String
  comentarios   String?
  fechaCreacion DateTime               @default(now())
  fechaCierre   DateTime?

  SeguimientoTicket SeguimientoTicket[]
}

model SeguimientoTicket {
  id       Int           @id @default(autoincrement())
  ticketId Int
  ticket   TicketSoporte @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  usuarioId Int // Usuario que realizó el soporte (técnico)
  usuario   Usuario @relation(fields: [usuarioId], references: [id], onDelete: Cascade)

  descripcion   String // Acción realizada (o más bien comentarios que iremos dejando como en el crm)
  fechaRegistro DateTime @default(now())
  // estadoNuevo     EstadoTicketSoporte
}

model Usuario {
  id                Int                 @id @default(autoincrement())
  empresaId         Int // Relación con la empresa
  empresa           Empresa             @relation(fields: [empresaId], references: [id], onDelete: Cascade)
  sucursalId        Int? // Relación opcional con una sucursal
  nombre            String
  correo            String              @unique
  telefono          String?
  rol               RolUsuario // Enum para roles (ADMIN, COBRADOR, TECNICO, etc.)
  activo            Boolean             @default(true)
  creadoEn          DateTime            @default(now())
  actualizadoEn     DateTime            @updatedAt
  Ruta              Ruta[]
  // Relación con tickets donde el usuario es el técnico asignado
  ticketsAsignados  TicketSoporte[]     @relation("TicketTecnico")
  // Relación con tickets donde el usuario creó el ticket
  ticketsCreados    TicketSoporte[]     @relation("TicketCreador")
  //usuarios que pueden comentar los tickets
  SeguimientoTicket SeguimientoTicket[]

  //referencia a los clientes que le dimos asesoramiento, o bien que fueron creados por nosotros
  clientesAsesorados ClienteInternet[]

  //Registros de caja chica
  RegistroCaja RegistroCaja[]
}

enum EstadoRuta {
  ACTIVO
  CERRADO
  CANCELADO
}

enum EstadoCliente {
  ACTIVO
  MOROSO
  SUSPENDIDO
  DESINSTALADO
}

enum EstadoServicio {
  ACTIVO
  INACTIVO
}

enum EstadoFacturaInternet {
  PENDIENTE
  PAGADA
  ATRASADA
  CANCELADA
}

enum EstadoTicketSoporte {
  ABIERTA
  EN_PROCESO
  PENDIENTE_CLIENTE
  PENDIENTE_TECNICO
  RESUELTA
  CANCELADA
}

enum TipoFactura {
  INTERNET
  SERVICIO_ADICIONAL
}

enum PrioridadTicketSoporte {
  BAJA
  MEDIA
  ALTA
  CRITICA
}

enum RolUsuario {
  TECNICO
  OFICINA
  ADMIN
  SUPER_ADMIN
}

enum EstadoClienteServicio {
  ACTIVO
  SUSPENDIDO
  CANCELADO
}

enum MetodoPago {
  EFECTIVO
  TARJETA
  TRANSFERENCIA
  PAYPAL
}

enum EstadoFactura {
  PENDIENTE
  PAGADA
  ATRASADA
  CANCELADA
}

enum MetodoPagoFacturaInternet {
  EFECTIVO
  TARJETA
  TRANSFERENCIA
  PAYPAL
}
